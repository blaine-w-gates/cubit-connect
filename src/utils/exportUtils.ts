import { TaskItem, CubitStep } from '@/services/storage';

// Helper to sanitize filenames
export const getSafeFilename = (title: string): string => {
  return title
    .replace(/[^a-z0-9]+/gi, '_')
    .toLowerCase()
    .replace(/^_+|_+$/g, '');
};

// Helper to format time MM:SS
const formatTime = (seconds: number) => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
};

// Recursive helper for steps
const formatStep = (step: CubitStep | string, depth: number, index: number): string => {
  let content = '';
  let children: (string | CubitStep)[] = [];
  let isCompleted = false;

  // Robust Content Extraction
  if (typeof step === 'string') {
    content = step;
  } else if (typeof step === 'object' && step !== null) {
    // Explicitly check for 'text' property, fallback to safely stringified representation or placeholder
    content = step.text || 'Untitled Step';
    children = step.sub_steps || [];
    isCompleted = step.isCompleted || false;
  } else {
    content = String(step);
  }

  let line = '';
  if (depth === 0) {
    // Level 1: Numbered Checkbox (e.g., "1. [ ] Step Name")
    const mark = isCompleted ? 'x' : ' ';
    line = `${index}. [${mark}] ${content}`;
  } else {
    // Level 2+: Indented Bullet (e.g., "    - Sub-step")
    // Indent logic: 4 spaces per depth level to align with Markdown list nesting
    const indent = '    '.repeat(depth);
    line = `${indent}- ${content}`;
  }

  // Recurse for children
  if (children && Array.isArray(children) && children.length > 0) {
    const childLines = children.map((child, i) => formatStep(child, depth + 1, i + 1)).join('\n');
    return line + '\n' + childLines;
  }

  return line;
};

export const generateMarkdown = (tasks: TaskItem[], title: string = 'Cubit Export'): string => {
  const md = `# ${title}\n\nGenerated by Cubit Connect\n\n---\n\n`;

  const taskContent = tasks.map((task) => {
    // H1 Task Name + Timestamp (if valid)
    const timestamp = task.timestamp_seconds > 0 ? ` (${formatTime(task.timestamp_seconds)})` : '';
    let section = `## ${task.task_name}${timestamp}\n\n`;

    // Description blockquote
    if (task.description) {
      section += `> ${task.description}\n\n`;
    }

    // Sub-steps (Recursive)
    if (task.sub_steps && task.sub_steps.length > 0) {
      const stepsBlock = task.sub_steps.map((step, idx) => formatStep(step, 0, idx + 1)).join('\n');
      section += stepsBlock + `\n`;
    }

    return section;
  }).join('\n'); // Spacer between tasks

  return md + taskContent;
};

export const downloadMarkdown = (tasks: TaskItem[], title: string = 'cubit-export') => {
  const markdown = generateMarkdown(tasks, title);
  const filename = `${getSafeFilename(title)}.md`;

  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
